// Filename: kinect_vrml.cpp
// Author: Jason Tennyson
// Date: 4-7-11
// 
// This file is designed to be used after the openni_camera driver is launched
// for use with the Microsoft KINECT.  It reads a single point cloud message
// from the KINECT, formats the data, and stores it in two different file formats.

#include <ros/ros.h>
#include <fstream>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>

// The templated pcl object type.
typedef pcl::PointXYZRGB PointT;

// This is the size of the tabbed white space that we use
// to signify that we are inside of a certain vrml scope.
#define	TAB_SIZE (2)

// This boolean value is set to true when we get a point cloud.
// The program loops until it gets a point cloud and sets this to true.
bool DATA_FULL = false;

// Our callback function that receives data from the kinect.
void pcdCallback(const sensor_msgs::PointCloud2 msg)
{
  // The number of spaces we print before we start to write a field name in the vrml file.
  // The number of spaces starts at 0 and varies by +/- TAB_SIZE above.
  // This just makes the file more readable.
  int numSpaces = 0;

  // An empty cloud for storing everything as float values.
  pcl::PointCloud<PointT>::Ptr cloud (new pcl::PointCloud<PointT> ());

  // Fill the empty cloud with data from the kinect.
  pcl::fromROSMsg(msg,*cloud);

  // Create and open the output files.
  std::ofstream vrml_file("kinect_out.wrl");
  std::ofstream pts_file("kinect_out.pts");

  // Write the header and types that wrap the points list in the wrl file.
  vrml_file << "#VRML V2.0 utf8\n";
  vrml_file << "# Automatically generated by kinect_vrml in ROS.\n\n";
  vrml_file << "Group {\n";
  numSpaces += TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "children [\n";
  numSpaces += TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "Transform {\n";
  numSpaces += TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "scale 1 1 1\n";
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "children [\n";
  numSpaces += TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "Shape {\n";
  numSpaces += TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "geometry PointSet {\n";
  numSpaces += TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "coord Coordinate {\n";
  numSpaces += TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "point [\n";
  numSpaces += TAB_SIZE;

  // This is the entire data dump for the pts file and only the points data dump for the wrl file.
  // Loop for the number of rows we have.
  for(unsigned int i = 0; i < cloud->points.size(); i++)
  {
    // If x y and z are numbers, we print the line.
    // If any of them are NaN, a != comparison with themselves returns true.
    if(!((cloud->points[i].x != cloud->points[i].x) ||
         (cloud->points[i].y != cloud->points[i].y) ||
         (cloud->points[i].z != cloud->points[i].z)))
    {
      // Grab the x y and z values and pad the middle with junk for the pts file.
      pts_file << cloud->points[i].x << " ";
      pts_file << cloud->points[i].y << " ";
      pts_file << cloud->points[i].z << " ";
      pts_file << 0 << " ";

      // Extract the bytes that we need for rgb in the pts file.
      // This nasty cast converts the rgb float to an int that we can bit mask.
      int rgb = *reinterpret_cast<int*>(&cloud->points[i].rgb);
      pts_file << ((rgb >> 16) & 0xff) << " ";
      pts_file << ((rgb >> 8) & 0xff) << " ";
      pts_file << (rgb & 0xff) << "\n";

      // Print only the points to the vrml file.
      for(int k = 0; k < numSpaces; k++) { vrml_file << " "; }
      vrml_file << cloud->points[i].x << " ";
      vrml_file << cloud->points[i].y << " ";
      vrml_file << cloud->points[i].z << ",\n";
    }
  }

  // Wrap the other side of the points list with their end brackets.
  numSpaces -= TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "] # end of point\n";
  numSpaces -= TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "} # end of Coordinate\n";

  // Print the colors field indicators.
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "color Color {\n";
  numSpaces += TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "color [\n";
  numSpaces += TAB_SIZE;

  // Color data dump for the vrml file.
  // Loop for the number of rows we have.
  for(unsigned int i = 0; i < cloud->points.size(); i ++)
  {
    // If x y and z are numbers, we print the line.
    if(!((cloud->points[i].x != cloud->points[i].x) ||
         (cloud->points[i].y != cloud->points[i].y) ||
         (cloud->points[i].z != cloud->points[i].z)))
    {
      // Extract the bytes that we need for rgb.
      for(int k = 0; k < numSpaces; k++) { vrml_file << " "; }
      // This nasty cast converts the rgb float to an int that we can bit mask.
      int rgb = *reinterpret_cast<int*>(&cloud->points[i].rgb);
      vrml_file << (float)((rgb >> 16) & 0xff)/255.0 << " ";
      vrml_file << (float)((rgb >> 8) & 0xff)/255.0 << " ";
      vrml_file << (float)(rgb & 0xff)/255.0 << ",\n";
    }
  }

  // Print the end brackets for all of the fields that we opened.
  numSpaces -= TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "] # end of color\n";
  numSpaces -= TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "} # end of Color\n";
  numSpaces -= TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "} # end of PointSet\n";
  numSpaces -= TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "} # end of Shape\n";
  numSpaces -= TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "] # end of children\n";
  numSpaces -= TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "} # end of Transform\n";
  numSpaces -= TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "] # end of children\n";
  numSpaces -= TAB_SIZE;
  for(int i = 0; i < numSpaces; i++) { vrml_file << " "; }
  vrml_file << "} # end of Group\n";

  // Close the files properly.
  vrml_file.close();
  pts_file.close();

  // We are done running the program.
  ROS_INFO("Done!");
  DATA_FULL = true;
}

int main(int argc, char **argv)
{
  // Initializes the node as a kinect listener.
  ros::init(argc, argv, "kinect_to_vrml");

  // Create an empty node handle.
  ros::NodeHandle n;

  // Create a subscriber on the depth topic.
  ros::Subscriber sub = n.subscribe("camera/depth/points2", 1000, pcdCallback);

  // Waits for new data. Then, the callback function is executed.
  while((!DATA_FULL) && ros::ok())
  {
    ros::spinOnce();
  }

  return 0;
}

